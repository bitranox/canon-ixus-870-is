// DecompileJPCOREInput2.java — Ghidra headless script
// Decompiles key JPCORE input data path functions from IXUS 870 IS firmware (1.01a)

import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileResults;
import ghidra.app.script.GhidraScript;
import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.FunctionManager;
import ghidra.program.model.symbol.SourceType;

import java.io.FileWriter;
import java.io.PrintWriter;

public class DecompileJPCOREInput2 extends GhidraScript {

    // Function addresses and descriptive names
    private static final long[][] FUNCTIONS = {
        { 0xFF92FE8CL, },
        { 0xFFA08764L, },
        { 0xFFA08D40L, },
        { 0xFF9E508CL, },
        { 0xFF9E51D8L, },
        { 0xFF8C4208L, },
        { 0xFF85DD14L, },
        { 0xFF9E8190L, },
        { 0xFF9E81A0L, },
    };

    private static final String[] NAMES = {
        "sub_FF92FE8C — Movie frame getter (4 output pointers: jpeg_ptr, jpeg_size, meta1, meta2)",
        "FUN_ffa08764 — Called after JPCORE_DMA_Start in PipelineStep3",
        "FUN_ffa08d40 — Called after JPCORE_DMA_Start in PipelineStep3",
        "FUN_ff9e508c — Video recording path in FrameProcessing (param_4=2/3)",
        "FUN_ff9e51d8 — General/EVF path in FrameProcessing (param_4=1)",
        "FUN_ff8c4208 — One-shot DMA capture setup (from GetContinuousMovieJpegVRAMData)",
        "FUN_ff85dd14 — Movie recording +0xA0 callback (before sub_FF92FE8C)",
        "FUN_ff9e8190 — JPCORE pipeline enable (called by StartMjpegMaking inner)",
        "FUN_ff9e81a0 — JPCORE pipeline disable (called by StopMjpegMaking inner)",
    };

    private static final String OUTPUT_FILE =
        "C:\\projects\\ixus870IS\\firmware-analysis\\jpcore_input2_decompiled.txt";

    @Override
    public void run() throws Exception {
        PrintWriter out = new PrintWriter(new FileWriter(OUTPUT_FILE));
        out.println("=======================================================================");
        out.println("JPCORE Input Data Path — Decompiled Functions");
        out.println("Firmware: Canon IXUS 870 IS / SD880 IS, version 1.01a");
        out.println("Processor: ARM:LE:32:v5t (Digic IV), base 0xFF810000");
        out.println("Generated by DecompileJPCOREInput2.java (Ghidra headless)");
        out.println("=======================================================================");
        out.println();

        FunctionManager funcMgr = currentProgram.getFunctionManager();

        // Set up the decompiler
        DecompInterface decomp = new DecompInterface();
        decomp.openProgram(currentProgram);

        for (int i = 0; i < FUNCTIONS.length; i++) {
            long addr = FUNCTIONS[i][0];
            String desc = NAMES[i];
            Address funcAddr = currentProgram.getAddressFactory()
                .getDefaultAddressSpace().getAddress(addr);

            out.println("-----------------------------------------------------------------------");
            out.printf("Function %d/%d: %s%n", i + 1, FUNCTIONS.length, desc);
            out.printf("Address: 0x%08X%n", addr);
            out.println("-----------------------------------------------------------------------");

            // Try to get existing function; create if missing
            Function func = funcMgr.getFunctionAt(funcAddr);
            if (func == null) {
                println("No function at " + funcAddr + ", creating one...");
                func = createFunction(funcAddr, null);
                if (func == null) {
                    // Try disassembling first then creating
                    disassemble(funcAddr);
                    func = createFunction(funcAddr, null);
                }
            }

            if (func == null) {
                out.println("[ERROR] Could not create function at this address.");
                out.println();
                println("ERROR: Could not create function at " + funcAddr);
                continue;
            }

            out.printf("Function name in Ghidra: %s%n", func.getName());
            out.printf("Function size: %d bytes%n",
                func.getBody().getNumAddresses());
            out.println();

            // Decompile
            DecompileResults results = decomp.decompileFunction(func, 120, monitor);
            if (results.decompileCompleted()) {
                String code = results.getDecompiledFunction().getC();
                out.println(code);
            } else {
                out.println("[ERROR] Decompilation failed: " + results.getErrorMessage());
            }
            out.println();
        }

        decomp.dispose();
        out.close();

        println("DecompileJPCOREInput2: Output written to " + OUTPUT_FILE);
    }
}
