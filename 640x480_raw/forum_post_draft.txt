================================================================================
CHDK FORUM POST DRAFT
================================================================================
Board: General Discussion and Assistance
Subject: Native 640x480 USB Webcam Streaming — IXUS 870 IS (CHDK module + PC bridge)
================================================================================

[b]TL;DR:[/b] I built a CHDK module + PC-side bridge that turns the IXUS 870 IS into a real USB webcam at 640x480 @ ~5 FPS. It captures raw UYVY frames directly from the ISP video pipeline and streams them over PTP. The PC bridge converts to RGB and presents a DirectShow virtual webcam visible in Zoom/Teams/OBS. Source code available.

[hr]

[b][size=14pt]What it does[/size][/b]

This is a CHDK module ("webcam.flt") that streams 640x480 video from the camera to a PC over USB, where a companion application ("chdk-webcam.exe") presents it as a virtual webcam device.

[b]Performance:[/b]
[list]
[li]Resolution: 640x480 (native ISP output, no upscaling)[/li]
[li]Frame rate: ~4.8 FPS sustained[/li]
[li]Frame size: 614,400 bytes/frame (uncompressed UYVY)[/li]
[li]USB throughput: ~2.9 MB/s[/li]
[li]Zero dropped frames over 5000+ frame runs[/li]
[li]Zero CPU encoding load on camera (raw passthrough)[/li]
[li]Unlimited streaming duration (auto-power-off disabled)[/li]
[/list]

For comparison, the software JPEG fallback path (which also works) achieves ~1.3 FPS. The raw UYVY approach is 3.5x faster because all encoding is moved to the PC.

[b]Tested on:[/b] IXUS 870 IS (SD880 IS), firmware 1.01a, CHDK 1.6.x

[hr]

[b][size=14pt]How it works[/size][/b]

The module uses a technique I haven't seen documented before: installing a callback spy in the firmware's recording pipeline to intercept ISP video frames before they reach the JPCORE hardware encoder.

[b]Camera-side pipeline:[/b]
[code]
1. webcam_start() switches camera to video mode (MODE_VIDEO_STD)
   → ISP pipeline starts producing 640x480 UYVY frames at 30 fps

2. hw_mjpeg_start() activates the recording pipeline:
   → StartMjpegMaking()           — enables JPCORE (sets state[+0x48]=1)
   → state[+0xD4] = 2             — forces video recording path in FrameProcessing
   → state[+0x114] = our_callback — installs spy in recording callback slot

3. Pipeline callback fires at 30 fps with arg2 = UYVY frame buffer address
   → Firmware rotates through 3 DMA ring buffers in uncached RAM:
     0x40BAADD0, 0x40C7DCD0, 0x40D50BD0

4. capture_frame_uyvy() copies 614 KB from DMA buffer (word-aligned, ~3ms)

5. PTP transfer: opcode 0x9999, sub-command 15 (GetMJPEGFrame)
   → param4 encodes format (0x01=UYVY) in high byte + frame counter in low 24 bits
[/code]

[b]PC-side bridge:[/b]
[code]
1. libusb PTP client receives raw UYVY frame (614,400 bytes)
2. BT.601 fixed-point UYVY→RGB24 conversion
3. Output to DirectShow virtual webcam ("CHDK Webcam" device)
4. Also: Win32 GDI preview window for monitoring
[/code]

[b]The key trick — state[+0xD4] = 2:[/b]

The firmware's FrameProcessing dispatcher (called from PipelineFrameCallback at 30 fps) checks state[+0xD4] to decide the processing path:
- Value 0 or 1 → EVF/LCD path (FUN_ff9e51d8, ISP mode 4) — only feeds the LCD
- Value 2 or 3 → Video recording path (FUN_ff9e508c, ISP mode 5) — fires recording callbacks

By setting state[+0xD4]=2 after StartMjpegMaking, we get the firmware to call our function pointer at state[+0x114] on every pipeline frame with the UYVY buffer address in arg2. Without this, no callbacks fire and we get nothing.

[hr]

[b][size=14pt]Digic IV firmware findings (IXUS 870 IS fw 1.01a)[/size][/b]

During development I spent considerable time reverse-engineering the JPCORE hardware JPEG encoder and the video recording pipeline in Ghidra. I'm sharing these findings because I couldn't find any existing documentation on this:

[b]MJPEG state structure at RAM 0x70D8:[/b]
(ROM literal pool at DAT_ff8c2e24 and DAT_ff8c43f4)

[code]
Offset   Purpose
+0x48    MJPEG active flag (0=off, 1=on) — set by StartMjpegMaking
+0x54    DMA status
+0x58    Frame index for DMA
+0x5C    DMA request state (3=requested, 4=stopped, 5=stopping)
+0x64    VRAM buffer address (0x40EA23D0)
+0xD4    Video mode: 1=EVF/LCD, 2=VGA recording, 3=QVGA recording
+0xEC    Pipeline active flag (must be 1 before StartMjpegMaking)
+0x114   Recording callback 1 — called as function pointer from FUN_ff8c335c
+0x118   Recording callback 2
+0x6C    Recording buffer address
[/code]

[b]JPCORE hardware encoder state:[/b]
[code]
JPCORE state struct at RAM 0x2554:
  +0x0C (piVar1[3])  — DMA active flag (1=running)
  +0x10 (piVar1[4])  — JPCORE output buffer address
  +0x14 (piVar1[5])  — Must be != -1 for JPCORE to start
  +0x20 (piVar1[8])  — Must be 0 for JPCORE to start
  +0x1C (piVar1[7])  — Semaphore handle

Buffer array at RAM 0x2580:
  buf[2] (0x2588)    — JPCORE output buffer for VGA video modes

JPCORE HW registers:
  0xC0F04908          — DMA output destination address
  0xC0F0103C          — JPCORE enable register
  0xC0F110C4          — ISP source routing (4=EVF, 5=VIDEO)

PipelineStep3 state at RAM 0x8224:
  +0x0C               — Completion bitmask (bit0=JPCORE fail, bit1+2=pre/post)
[/code]

[b]Why hardware JPEG encoding doesn't work (yet):[/b]

JPCORE initializes and reports active (PS3 completion mask=6, DMA started successfully) but never produces output. Root cause: the recording callbacks at state[+0x114]/[+0x118] are what transfer JPCORE-encoded frames to the output. During normal movie recording, movie_record_task populates these via sub_FF8C3BFC(0xFF85D370, 0x1AB94, 0xFF85D28C). But these callbacks CRASH the camera when called outside movie_record_task context — they expect AVI ring buffer state, frame counters, etc. that aren't initialized.

So the JPCORE hardware is encoding frames internally, but nobody collects them. A lightweight custom callback that captures JPCORE output without crashing is the missing piece. For now, raw UYVY from the pre-encoding pipeline is faster anyway (~5 FPS vs the theoretical HW JPEG path).

[b]UYVY chroma encoding (non-standard):[/b]

Digic IV stores U/V chroma bytes as [b]signed int8[/b] centered at 0 (range -128..+127), NOT unsigned uint8 centered at 128 (standard UYVY). If you interpret them as unsigned and subtract 128, all whites/grays turn green. You must cast to int8_t directly:
[code]
// WRONG: int u = (int)src[0] - 128;    ← green cast on neutral colors
// RIGHT: int u = (int)(int8_t)src[0];   ← correct colors
[/code]
This applies to both the UYVY video pipeline buffers and the UYVYYY viewport buffers.

[b]Firmware function addresses (fw 1.01a):[/b]
[code]
StartMjpegMaking                 0xFF9E8DD8  (0 args)
StopMjpegMaking                  0xFF9E8DF8  (0 args)
GetContinuousMovieJpegVRAMData   0xFFAA234C  (4 args — BLOCKS FOREVER, do not use)
GetMovieJpegVRAMHPixelsSize      0xFF8C4178  (0 args → returns 640)
GetMovieJpegVRAMVPixelsSize      0xFF8C4184  (0 args → returns 480)
StopContinuousVRAMData           0xFF8C425C  (4 args)
StartEVFMovVGA                   0xFF9E8944  (4 args — 640x480@30fps mode)
FW_JPCORE_PowerInit              0xFF8EEB6C  (ref-counted power on)
[/code]

[b]Warning about GetContinuousMovieJpegVRAMData:[/b] This function blocks forever when the recording pipeline isn't fully initialized. It waits on a DryOS event flag with timeout=0 (infinite). If you call it after StartMjpegMaking without full movie_record_task setup, the camera hangs permanently and must be power-cycled.

[hr]

[b][size=14pt]Architecture[/size][/b]

[code]
Camera side (CHDK module):
  webcam.c    — Main module: mode switching, pipeline setup, frame capture
  webcam.h    — Module interface (webcam_frame_t, webcam_status_t, libwebcam_sym)
  tje.c/h     — Tiny JPEG Encoder with added UYVY support (software fallback)
  ptp.c       — PTP handler: sub-command 15 (GetMJPEGFrame), start/stop/get_frame

PC side (Windows bridge):
  ptp_client.cpp  — libusb-1.0 PTP client, session management, CHDK protocol
  frame_processor.cpp — BT.601 UYVY→RGB24 with signed chroma handling
  virtual_webcam.cpp  — DirectShow source filter ("CHDK Webcam")
  preview_window.cpp  — Win32 GDI preview window
  main.cpp            — Streaming loop, CLI options
[/code]

The PTP protocol uses CHDK's existing opcode 0x9999 with a new sub-command (15 = GetMJPEGFrame). The sub-command multiplexes start, stop, and frame retrieval:
- param3=0x01: Start webcam (returns 576 bytes of pipeline diagnostics)
- param3=0x00: Get frame (returns raw UYVY or JPEG + metadata in response params)
- param3=0x02: Stop webcam

[hr]

[b][size=14pt]What I'd like to contribute[/size][/b]

I'm happy to share all of this with the CHDK community:

1. [b]The webcam module source code[/b] — camera-side CHDK module for 640x480 webcam streaming
2. [b]The PC bridge source code[/b] — Windows bridge application (libusb + DirectShow)
3. [b]Digic IV JPCORE/pipeline RE findings[/b] — state structures, function addresses, pipeline routing
4. [b]The signed chroma discovery[/b] — may be relevant for any CHDK code dealing with YUV buffers

The code is currently IXUS 870 IS specific (hardcoded firmware addresses), but the approach should work on any Digic IV camera with video mode — the pipeline callback mechanism and state structure layout appear to be shared firmware code.

I'm interested in hearing from the devs whether:
- This would be useful as a trunk module (with proper multi-camera abstraction)?
- The PTP sub-command should be a new official CHDK PTP command?
- The firmware findings should go on the wiki?
- Or if standalone distribution as a .flt + bridge download makes more sense?

The Tiny JPEG Encoder (tje.c) is MIT licensed — I believe that's GPL-compatible but want to double-check before any trunk inclusion.

Source code: [i](will add link once I set up a public repository)[/i]

[hr]

[b][size=14pt]Things that don't work / known limitations[/size][/b]

[list]
[li]JPCORE hardware JPEG: Initialized but output discarded (see above). Would need a custom lightweight callback.[/li]
[li]Resolution: Fixed at 640x480 (camera's video mode). No zoom, no higher resolution.[/li]
[li]FPS: ~5 FPS, limited by USB 2.0 bulk transfer of 614 KB/frame + memcpy overhead.[/li]
[li]LCD goes black: Setting state[+0xD4]=2 switches the display pipeline to movie recording format, which corrupts the LCD. The camera is effectively blind while streaming.[/li]
[li]PC only: Bridge is Windows-only (DirectShow). A Linux v4l2loopback version would be straightforward.[/li]
[li]Single camera: Firmware addresses are hardcoded for IXUS 870 IS fw 1.01a.[/li]
[li]sub_FF8C3BFC: Do NOT call with movie_record_task callbacks outside of movie recording — instant crash.[/li]
[/list]

[hr]

[b][size=14pt]Screenshots / demo[/size][/b]

[i](TODO: add preview window screenshot showing 640x480 stream)[/i]

[hr]

Happy to answer questions or share more RE details. This has been a fun project — the IXUS 870 IS is 17 years old but still produces surprisingly usable webcam video.
